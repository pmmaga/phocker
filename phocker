#!/usr/bin/env php
<?php declare(strict_types=1);

function help() {
    echo <<<END
phocker
-------
An exercise in self-isolation using PHP

Usage: phocker run [command to be executed]

It expects a rootfs available in the rootfs/ folder
(ex: http://cdimage.ubuntu.com/ubuntu-base/releases/)

END;
}

/**
 * run is the parent process of phocker
 * 
 * It will fork and call unshare with the necessary flags
 * and execute this file again calling the child command.
 * This effectively creates the new namespaces and the child
 * is added to them.
 *
 * @param string $arg The command to run in the container
 * @return void
 */
function run(string $arg) {
    // We make use of unshare(1) because currently there is no way
    // to call unshare(2) with the necessary flags from the userland
    $mapRootUser = (posix_getuid() === 0 ? "" : "--map-root-user");
    $unshare = "unshare --mount --ipc --pid --uts $mapRootUser --fork " . __FILE__ . " child $arg";
    $proc = proc_open($unshare, [STDIN, STDOUT, STDERR], $pipes);
    $exitCode = proc_close($proc);

    exit($exitCode);
}

/**
 * child is the child process called via unshare
 * 
 * Now we are already in the new namespace.
 * After setting up cgroups, chroot to rootfs/ and mounting /proc
 * we run the command given by the user.
 *
 * @param string $arg The command to run in the container
 * @return void
 */
function child(string $arg) {
    // If we have cgroups and permissions to write there
    if (is_writable("/sys/fs/cgroup/pids")) {
        doCgroup("pids", ["pids.max" => 20]);
        doCgroup("memory", ["memory.limit_in_bytes" => "100M"]);
    }
    doChroot();
    mountProc();
    system("hostname phocker"); // ;)

    $proc = proc_open($arg, [STDIN, STDOUT, STDERR], $pipes);
    $exitCode = proc_close($proc);

    unmountProc();

    exit($exitCode);
}

function doCgroup(string $namespace, array $rules) {
    // Create the new group
    $cgroupPath = "/sys/fs/cgroup/$namespace/phocker";
    if(!is_dir($cgroupPath)) {
        mkdir($cgroupPath, 0755);
    }

    foreach ($rules as $k => $v) {
        file_put_contents("$cgroupPath/$k", $v);
    }

    file_put_contents($cgroupPath . "/notify_on_release", "1");
    file_put_contents($cgroupPath . "/cgroup.procs", getmypid());
}

function doChroot() {
    if(!chroot(__DIR__ . '/rootfs')) {
        // If chroot fails, fail as well
        trigger_error("chroot failed", E_USER_ERROR);
    }
    chdir("/");
}

function mountProc() {
    system("mount -t proc proc /proc", $ret);
    if ($ret != 0) {
        trigger_error("mount exited with $ret", E_USER_WARNING);
    }
}

function unmountProc() {
    system("umount /proc", $ret);
    if ($ret != 0) {
        trigger_error("umount exited with $ret", E_USER_WARNING);
    }
}

if (count($argv) < 3) {
    help();
}
$cmd = $argv[1];

switch ($cmd) {
    case "run":
        run(implode(' ', array_slice($argv, 2)));
        break;
    case "child":
        child(implode(' ', array_slice($argv, 2)));
        break;
    default:
        help();
        break;
}
